<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>BLAST TRAINER - English Learning Fun!</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-gradient-start: #f0f4f8; /* Light Grayish Blue */
      --bg-gradient-end: #e6e9f0; /* Lighter Grayish Blue */
      --primary-color: #6A82FB; /* Soft Blue */
      --secondary-color: #FCB69F; /* Soft Orange/Peach */
      --accent-color: #84E1BC; /* Mint Green */
      --text-color: #3D4758; /* Dark Slate Gray */
      --text-light-color: #ffffff;
      --correct-color: #5CB85C; /* Success Green */
      --incorrect-color: #D9534F; /* Danger Red */
      --disabled-color: #B0BEC5; /* Light Gray */
      --card-bg: #ffffff;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --font-family: 'Nunito', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family);
      background: linear-gradient(135deg, var(--bg-gradient-start), var(--bg-gradient-end));
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 5px; /* Reduced horizontal padding for body */
      overflow-x: hidden;
    }

    .container {
      max-width: 700px;
      width: 100%;
      text-align: center;
      padding: 10px; /* Reduced container padding */
    }

    h1 {
      font-size: 2.5em; /* Slightly reduced for mobile */
      color: var(--primary-color);
      margin-bottom: 25px; /* Reduced margin */
      font-weight: 800;
      letter-spacing: 1px;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    h1:hover {
      color: var(--secondary-color);
    }

    /* h2 elements are removed from HTML for setup screen */

    .setup-screen, .game-screen, .result-screen {
      background-color: var(--card-bg);
      padding: 20px; /* Uniform padding */
      border-radius: 20px;
      box-shadow: 0 8px 25px var(--shadow-color); /* Adjusted shadow */
      width: 100%;
      animation: fadeIn 0.5s ease-out;
      margin-bottom: 20px; /* Added margin between screens if they were to stack (though they don't) */
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(15px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .setup-screen { display: block; }
    .game-screen, .result-screen { display: none; }

    .selection {
      margin-bottom: 25px; /* Adjusted margin */
    }
    .selection:last-of-type {
        margin-bottom: 20px; /* Less margin for the last selection group before start button */
    }


    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px; /* Reduced gap */
      justify-content: center;
      /* margin-bottom: 15px; Removed, spacing handled by .selection */
    }

    .btn {
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease-out;
      color: var(--text-color);
      padding: 10px 18px; /* Adjusted padding */
      border-radius: 20px; 
      background-color: #f0f0f0;
      font-size: 0.95em; /* Adjusted font size */
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .btn:hover {
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 3px 8px rgba(0,0,0,0.1);
    }
    .btn.selected {
      background-color: var(--primary-color);
      color: var(--text-light-color);
      box-shadow: 0 3px 10px rgba(var(--primary-color-rgb, 106, 130, 251), 0.35);
      transform: scale(1.03);
    }
    :root { --primary-color-rgb: 106, 130, 251; }


    .start-btn, .restart-btn {
      padding: 14px 30px; /* Adjusted padding */
      font-size: 1.1em; /* Adjusted font size */
      border-radius: 25px;
      color: var(--text-light-color);
      font-weight: 700;
      box-shadow: 0 4px 12px var(--shadow-color);
    }

    .start-btn {
      background-color: var(--accent-color);
      display: block; /* Make it block to control margin auto */
      margin: 0 auto; /* Center the button */
    }
    .start-btn:hover {
      background-color: #68c9a9; 
      transform: translateY(-3px) scale(1.03);
      box-shadow: 0 5px 18px rgba(132, 225, 188, 0.45);
    }
    .start-btn:disabled {
      background-color: var(--disabled-color);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      color: #777;
    }

    .restart-btn {
      background-color: var(--secondary-color);
    }
    .restart-btn:hover {
      background-color: #fa9f85;
        transform: translateY(-3px) scale(1.03);
      box-shadow: 0 5px 18px rgba(252, 182, 159, 0.45);
    }
   
    .progress-bar {
      width: 100%;
      height: 10px; /* Slimmer bar */
      background-color: #e0e0e0;
      border-radius: 5px;
      margin-bottom: 20px; /* Adjusted margin */
      overflow: hidden;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.08);
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
      width: 0%;
      transition: width 0.3s ease-in-out;
      border-radius: 5px;
    }

    .game-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px; /* Adjusted margin */
      font-size: 1em; /* Adjusted font size */
      font-weight: 600;
    }
    .timer { color: var(--primary-color); }
    .score { color: var(--secondary-color); }

    .word-display {
      background-color: #f8f9fa;
      border-radius: 15px;
      padding: 20px; /* Reduced padding */
      margin-bottom: 20px; /* Adjusted margin */
      border: 1px solid #eee;
      min-height: 100px; /* Reduced min-height */
      display: flex;
      flex-direction: column;
      justify-content: center; /* Content will be centered */
      align-items: center;
      position: relative; /* For positioning answer-display if needed */
    }
    .word {
      font-size: 2.2em; /* Adjusted font size */
      font-weight: 700;
      color: var(--text-color);
      margin-bottom: 10px; /* Reduced margin */
    }

    .choices {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px; /* Adjusted gap */
      margin-bottom: 20px; /* Adjusted margin */
    }
    .choice-btn {
      padding: 15px; /* Adjusted padding */
      font-size: 1em; /* Adjusted font size */
      border: 1px solid #ddd;
      background-color: var(--card-bg);
      color: var(--text-color);
      font-weight: 600;
      border-radius: 10px; 
    }
    .choice-btn:hover:not(:disabled) {
      border-color: var(--primary-color);
      color: var(--primary-color);
      transform: translateY(-2px);
    }
    .choice-btn.correct {
      background-color: var(--correct-color);
      border-color: var(--correct-color);
      color: var(--text-light-color);
      animation: pulse 0.5s;
    }
    .choice-btn.incorrect { /* This class is not used in current logic, marked-incorrect is used */
      background-color: var(--incorrect-color);
      border-color: var(--incorrect-color);
      color: var(--text-light-color);
    }
      .choice-btn.marked-incorrect { /* Used for incorrect attempts, allows re-clicking */
        background-color: var(--incorrect-color);
        border-color: var(--incorrect-color);
        color: var(--text-light-color);
        /* No shake animation by default to allow re-clicking without distraction, or a very subtle one */
    }
    .choice-btn.wiggle { /* Apply this class dynamically on incorrect click if needed */
        animation: shake 0.4s;
    }

    .choice-btn:disabled:not(.correct):not(.marked-incorrect) { 
      background-color: #f5f5f5;
      color: var(--disabled-color);
      cursor: not-allowed;
    }


    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @keyframes shake { /* Subtle shake */
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      75% { transform: translateX(3px); }
    }

    .answer-display {
      margin-top: 10px; /* Reduced margin */
      padding: 10px; /* Adjusted padding */
      background-color: rgba(0,0,0,0.03);
      border-radius: 8px;
      font-size: 0.95em; /* Adjusted font size */
      font-weight: 600;
      color: var(--text-color);
      min-height: 4em; /* MODIFIED for PC: Ensures space for 2 lines + padding */
      line-height: 1.4;
      visibility: hidden; /* Initially hidden but occupies space */
      opacity: 0;
      transition: opacity 0.3s ease, visibility 0s linear 0.3s; /* Delay visibility change */
      width: 100%; /* Take full width of its container */
    }
    .answer-display.visible {
      visibility: visible;
      opacity: 1;
      transition: opacity 0.3s ease, visibility 0s linear 0s;
    }
    .answer-display.correct-text { color: var(--correct-color); }
    .answer-display.incorrect-text { color: var(--incorrect-color); }


    .result-screen h2 {
      font-size: 1.8em; /* Adjusted font size */
      color: var(--primary-color);
      margin-bottom: 10px;
    }
    .final-score {
      font-size: 2.5em; /* Adjusted font size */
      color: var(--secondary-color);
      margin-bottom: 10px;
      font-weight: 800;
    }
    #finalMessage {
      font-size: 1.1em; /* Adjusted font size */
      margin-bottom: 25px;
      line-height: 1.5;
    }

    @media (max-width: 480px) { /* More specific mobile adjustments */
      body { padding: 10px 0px; } /* Remove side padding on body for smallest screens */
      .container { padding: 5px; }
      h1 { font-size: 2em; margin-bottom:20px; }
      .word { font-size: 1.8em; }
      .choices { grid-template-columns: 1fr; gap: 8px;}
     
      .setup-screen, .game-screen, .result-screen { padding: 15px; }

      .selection:nth-child(1) .buttons, /* Level buttons */
      .selection:nth-child(2) .buttons { /* Timer buttons */
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* Ensure buttons fit */
        gap: 8px;
      }
        .selection:nth-child(3) .buttons { /* Dir buttons */
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      .btn { padding: 10px 12px; font-size: 0.9em; }
      .start-btn, .restart-btn { padding: 12px 25px; font-size: 1em; }
      .choice-btn { padding: 12px; font-size: 0.95em;}

      .answer-display { 
        font-size: 0.9em; 
        min-height: 4.2em; /* MODIFIED for Mobile: Ensures space for 2 lines + padding */
      }
    }
  </style>
</head>

<body>
<div class="container">
  <h1 id="title">BLAST TRAINER</h1>

  <div class="setup-screen" id="setupScreen">
    <div class="selection">
      <div class="buttons">
        <button class="btn level-btn" data-level="5">英検5級</button>
        <button class="btn level-btn" data-level="4">4級</button>
        <button class="btn level-btn" data-level="3">3級</button>
        <button class="btn level-btn" data-level="p2">準2級</button>
        <button class="btn level-btn" data-level="2">2級</button>
        <button class="btn level-btn" data-level="p1">準1級</button>
        <button class="btn level-btn" data-level="1">1級</button>
      </div>
    </div>

    <div class="selection">
      <div class="buttons">
        <button class="btn timer-btn" data-time="60">1分</button>
        <button class="btn timer-btn" data-time="180">3分</button>
        <button class="btn timer-btn" data-time="300">5分</button>
        <button class="btn timer-btn" data-time="600">10分</button>
        <button class="btn timer-btn" data-time="0">無制限</button>
      </div>
    </div>

    <div class="selection">
      <div class="buttons">
        <button class="btn dir-btn selected" data-mode="en-ja">英語 ▶ 日本語</button>
        <button class="btn dir-btn" data-mode="ja-en">日本語 ▶ 英語</button>
      </div>
    </div>

    <button class="start-btn" id="startBtn" disabled>スタート！</button>
  </div>

  <div class="game-screen" id="gameScreen">
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>

    <div class="game-info">
      <div class="timer" id="timerDisplay">時間: --</div>
      <div class="score" id="scoreDisplay">スコア: 0/0</div>
    </div>

    <div class="word-display">
      <div class="word" id="currentWord">Loading...</div>
      <div class="answer-display" id="answerDisplay"></div> </div>

    <div class="choices" id="choices">
      </div>
  </div>

  <div class="result-screen" id="resultScreen">
    <h2>ゲーム終了！</h2>
    <div class="final-score" id="finalScore">0/0</div>
    <div id="finalMessage">お疲れ様でした！</div>
    <button class="restart-btn" id="restartBtn">もう一度挑戦！</button>
  </div>
</div>

<script>
/* ---------- Audio Context & Sound Effects ---------- */
let audioCtx;
const sounds = {
  click: null, correct: null, incorrect: null, start: null
};

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch (e) {
    console.warn("Web Audio API is not supported in this browser.");
  }
}

function createSound(type, freq1, freq2, duration, vol, attack = 0.01, decay = 0.1) {
  if (!audioCtx) return () => {}; 

  return () => {
    if(!audioCtx) return;
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    oscillator.type = type;
    oscillator.frequency.setValueAtTime(freq1, audioCtx.currentTime);
    if (freq2) {
      oscillator.frequency.exponentialRampToValueAtTime(freq2, audioCtx.currentTime + duration * 0.8);
    }

    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
    gainNode.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + attack);
    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration + decay);

    oscillator.start(audioCtx.currentTime);
    oscillator.stop(audioCtx.currentTime + duration + decay + 0.1);
  };
}

function setupSounds() {
    if (!audioCtx) return;
    sounds.click = createSound('triangle', 700, 500, 0.03, 0.15, 0.005, 0.03);
    sounds.correct = createSound('sine', 900, 1300, 0.08, 0.25, 0.01, 0.08);
    sounds.incorrect = createSound('square', 220, 180, 0.12, 0.20, 0.01, 0.12);
    sounds.start = createSound('sawtooth', 330, 660, 0.18, 0.28, 0.02, 0.18);
}

function playSound(soundName) {
  if (!audioCtx) initAudio(); 
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().then(() => {
        if (sounds[soundName]) sounds[soundName]();
    });
  } else if (sounds[soundName]) {
    sounds[soundName]();
  }
}

function firstInteractionListener() {
    initAudio();
    if(audioCtx) setupSounds(); 
    window.removeEventListener('click', firstInteractionListener, {capture: true}); // Use capture to ensure it runs early
    window.removeEventListener('touchstart', firstInteractionListener, {capture: true});
}
// Use capture for the event listener to try and catch it before other specific click listeners
window.addEventListener('click', firstInteractionListener, {capture: true, once: true});
window.addEventListener('touchstart', firstInteractionListener, {capture: true, once: true});


/* ---------- ユーティリティ ---------- */
const shuffle = a => {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
};

/* ---------- メインクラス ---------- */
class BlastTrainer {
  constructor() {
    this.level = null;
    this.timeLimit = null;
    this.playMode = 'en-ja'; 
    this.words = [];
    this.currentWordData = null; 
    this.shuffledQueue = [];
    this.currentQueueIndex = 0;
    this.score = 0;
    this.attempts = 0; // Total questions attempted (first try per question)
    this.currentQuestionAnsweredCorrectlyOnFirstTry = false; // ★MODIFIED: Flag for new scoring rule
    this.timeLeft = 0;
    this.timerIntervalId = null;
    this.isPlaying = false;

    this.setupScreenEl = document.getElementById('setupScreen');
    this.gameScreenEl = document.getElementById('gameScreen');
    this.resultScreenEl = document.getElementById('resultScreen');
    this.startBtnEl = document.getElementById('startBtn');
    this.titleEl = document.getElementById('title');
    this.timerDisplayEl = document.getElementById('timerDisplay');
    this.scoreDisplayEl = document.getElementById('scoreDisplay');
    this.progressFillEl = document.getElementById('progressFill');
    this.currentWordEl = document.getElementById('currentWord');
    this.answerDisplayEl = document.getElementById('answerDisplay');
    this.choicesEl = document.getElementById('choices');
    this.finalScoreEl = document.getElementById('finalScore');
    this.finalMessageEl = document.getElementById('finalMessage');
    this.restartBtnEl = document.getElementById('restartBtn');
   
    this.bindEvents();
    this.updateStartButtonState(); 
  }

  bindEvents() {
    // ★MODIFIED: Title click now also plays generic 'click' sound
    this.titleEl.addEventListener('click', () => { playSound('click'); location.reload(); });
    
    document.querySelectorAll('.level-btn').forEach(b => b.addEventListener('click', () => this.handleSelection(b, 'level')));
    document.querySelectorAll('.timer-btn').forEach(b => b.addEventListener('click', () => this.handleSelection(b, 'time')));
    document.querySelectorAll('.dir-btn').forEach(b => b.addEventListener('click', () => this.handleSelection(b, 'dir')));
    
    // ★MODIFIED: Start button click now also plays generic 'click' sound before starting game
    this.startBtnEl.addEventListener('click', () => {
      if (!this.startBtnEl.disabled) {
        playSound('click'); // Play click sound for setup screen button
        this.startGame(); // startGame will play its own 'start' sound
      }
    });
    this.restartBtnEl.addEventListener('click', () => this.restartGame());
  }

  handleSelection(buttonEl, type) {
    playSound('click'); // ★MODIFIED: Generic click sound for setup screen buttons
    const buttonClass = type === 'level' ? 'level-btn' : type === 'time' ? 'timer-btn' : 'dir-btn';
    document.querySelectorAll(`.${buttonClass}`).forEach(b => b.classList.remove('selected'));
    buttonEl.classList.add('selected');

    if (type === 'level') this.level = buttonEl.dataset.level;
    if (type === 'time') this.timeLimit = parseInt(buttonEl.dataset.time, 10);
    if (type === 'dir') this.playMode = buttonEl.dataset.mode;
   
    this.updateStartButtonState();
  }

  updateStartButtonState() {
    this.startBtnEl.disabled = !(this.level && this.timeLimit !== null);
  }

  async loadWordsFromFile() {
    try {
      const response = await fetch(`./data/words-${this.level}.txt`); 
      if (!response.ok) throw new Error(`Failed to load words for level ${this.level}`);
      const textData = await response.text();
      this.words = textData.trim().split('\n').map(line => {
        const [englishWord, japaneseWord] = line.split('\t');
        return { english: englishWord?.trim(), japanese: japaneseWord?.trim() };
      }).filter(word => word.english && word.japanese);

      if (this.words.length === 0) throw new Error('No words loaded or file is empty.');
    } catch (error) {
      console.warn(`Error loading words: ${error.message}. Using fallback data.`);
      this.words = Array.from({ length: 20 }, (_, i) => ({
        english: `Sample Word ${i + 1}`,
        japanese: `サンプル単語 ${i + 1}`
      }));
    }
  }

  async startGame() {
    // playSound('start') is played here, which is fine for game initiation.
    // The generic 'click' for the button press itself is now in bindEvents.
    playSound('start'); 
    this.setupScreenEl.style.display = 'none';
    this.gameScreenEl.style.display = 'block';
    this.resultScreenEl.style.display = 'none';
   
    await this.loadWordsFromFile();
   
    this.shuffledQueue = shuffle(this.words.slice());
    this.currentQueueIndex = 0;
    this.score = 0;
    this.attempts = 0; 
    this.isPlaying = true;
    this.timeLeft = this.timeLimit;

    if (this.timeLimit > 0) {
      this.startTimer();
    } else {
      this.updateTimerDisplay(); 
    }
    this.displayNextQuestion();
    this.updateScoreDisplay(); 
  }

  startTimer() {
    this.updateTimerDisplay();
    this.timerIntervalId = setInterval(() => {
      this.timeLeft--;
      this.updateTimerDisplay();
      if (this.timeLeft <= 0) {
        this.endGame();
      }
    }, 1000);
  }

  updateTimerDisplay() {
    if (this.timeLimit === 0) {
      this.timerDisplayEl.textContent = '時間: 無制限 ∞';
      return;
    }
    const minutes = Math.floor(this.timeLeft / 60);
    const seconds = String(this.timeLeft % 60).padStart(2, '0');
    this.timerDisplayEl.textContent = `時間: ${minutes}:${seconds}`;
  }

  displayNextQuestion() {
    if (!this.isPlaying) return;
    this.currentQuestionAnsweredCorrectlyOnFirstTry = false; // ★MODIFIED: Reset flag for the new question

    if (this.currentQueueIndex >= this.shuffledQueue.length) {
      this.shuffledQueue = shuffle(this.words.slice()); 
      this.currentQueueIndex = 0;
    }
    this.currentWordData = this.shuffledQueue[this.currentQueueIndex++];
   
    const questionWord = this.playMode === 'en-ja' ? this.currentWordData.english : this.currentWordData.japanese;
    const correctAnswer = this.playMode === 'en-ja' ? this.currentWordData.japanese : this.currentWordData.english;

    this.currentWordEl.textContent = questionWord;
   
    this.answerDisplayEl.textContent = ''; // Clear previous answer text
    this.answerDisplayEl.className = 'answer-display'; // Reset classes
    
    if (this.playMode === 'en-ja' && questionWord) { 
      this.speakWord(questionWord);
    }

    const otherWordsPool = this.words.filter(word => 
        (this.playMode === 'en-ja' ? word.japanese : word.english) !== correctAnswer && 
        (this.playMode === 'en-ja' ? word.english : word.japanese) !== questionWord
    );
    const wrongAnswers = shuffle(otherWordsPool)
      .slice(0, 3)
      .map(word => this.playMode === 'en-ja' ? word.japanese : word.english);
     
    const choicesArray = shuffle([correctAnswer, ...wrongAnswers]);
   
    this.choicesEl.innerHTML = ''; 
    choicesArray.forEach(choiceText => {
      const buttonEl = document.createElement('button');
      buttonEl.className = 'btn choice-btn';
      buttonEl.textContent = choiceText;
      buttonEl.addEventListener('click', () => this.handleAnswerSelection(
          buttonEl, 
          choiceText, 
          correctAnswer, 
          this.currentWordData.english, 
          this.currentWordData.japanese
      ));
      this.choicesEl.appendChild(buttonEl);
    });
    // Resetting attempts here could be problematic if we count attempts differently.
    // Let's manage 'attempts' increment only on the first click for a question in handleAnswerSelection.
    this.updateScoreDisplay(); // Update score display (e.g. 0/0 at start of question)
  }

  handleAnswerSelection(buttonEl, selectedAnswer, correctAnswer, currentQuestionEnglish, currentQuestionJapanese) {
    if (!this.isPlaying) return;

    // Check if this is the very first attempt for this specific question
    // We need a reliable way to know if this is the first click *for this question display*
    // The 'attempts' counter is for overall game progress, not for the current question's first try for scoring.
    // Let's use a temporary flag on the button or a state variable.
    // `this.currentQuestionAnsweredCorrectlyOnFirstTry` is reset in `displayNextQuestion`.
    // We also need to track if *any* attempt has been made for the current question to increment `this.attempts`.
    // A simple way: check if any button is already marked (correct/incorrect for this question).
    // Or better, a flag that's set on the first click for the current question.
    
    let isFirstClickForThisQuestion = true;
    const choiceButtons = this.choicesEl.querySelectorAll('.choice-btn');
    for(const btn of choiceButtons) {
        if(btn.classList.contains('marked-incorrect') || btn.classList.contains('correct')){
            isFirstClickForThisQuestion = false;
            break;
        }
    }


    let selectedWordObject;
    if (this.playMode === 'en-ja') { 
        selectedWordObject = this.words.find(w => w.japanese === selectedAnswer);
    } else { 
        selectedWordObject = this.words.find(w => w.english === selectedAnswer);
    }
    const selectedDisplayEnglish = selectedWordObject?.english || (this.playMode === 'ja-en' ? selectedAnswer : "???");
    const selectedDisplayJapanese = selectedWordObject?.japanese || (this.playMode === 'en-ja' ? selectedAnswer : "???");

    if (selectedDisplayEnglish && selectedDisplayEnglish !== "???") { 
        this.speakWord(selectedDisplayEnglish);
    }

    const isCorrect = selectedAnswer === correctAnswer;

    this.answerDisplayEl.classList.remove('correct-text', 'incorrect-text', 'visible');
    void this.answerDisplayEl.offsetWidth; 

    if (isCorrect) {
      playSound('correct');
      // ★MODIFIED: Score is only added if this is the first attempt for this question
      // and it hasn't been marked as correctly answered on first try already.
      if (isFirstClickForThisQuestion && !this.currentQuestionAnsweredCorrectlyOnFirstTry) {
        this.score++;
        this.currentQuestionAnsweredCorrectlyOnFirstTry = true; // Mark as scored for this question
      }
      
      buttonEl.classList.remove('marked-incorrect', 'wiggle'); 
      buttonEl.classList.add('correct');
     
      this.answerDisplayEl.textContent = `正解！ 「${currentQuestionEnglish}」は「${currentQuestionJapanese}」だね！`;
      this.answerDisplayEl.classList.add('correct-text');
     
      // Disable all buttons and visually mark the correct one
      document.querySelectorAll('.choice-btn').forEach(b => {
          b.disabled = true; 
          if (b !== buttonEl && b.textContent !== correctAnswer) { 
              b.style.opacity = "0.5"; 
          }
      });
      setTimeout(() => this.displayNextQuestion(), 1200); 
    } else { // Incorrect answer
      playSound('incorrect');
      buttonEl.classList.add('marked-incorrect'); 
      buttonEl.classList.add('wiggle');
      setTimeout(()=> buttonEl.classList.remove('wiggle'), 400);
      // Do not disable the button, allow user to try again.
      // The score will not be counted for subsequent correct answers on this same question.

      this.answerDisplayEl.textContent = `「${selectedDisplayEnglish}」は「${selectedDisplayJapanese}」だよ。`;
      this.answerDisplayEl.classList.add('incorrect-text');
    }
    
    // ★MODIFIED: Increment attempts only on the very first click for the current question.
    if (isFirstClickForThisQuestion) {
        this.attempts++;
    }

    this.answerDisplayEl.classList.add('visible');
    this.updateScoreDisplay();
  }
 
  speakWord(wordToSpeak) {
    if (!('speechSynthesis' in window) || !wordToSpeak) return;
    const utterance = new SpeechSynthesisUtterance(wordToSpeak);
    const voices = speechSynthesis.getVoices();
    let preferredVoice = voices.find(v => /en-(US|GB)/.test(v.lang) && (v.name.includes('Google') || v.localService || v.default));
    if (!preferredVoice) preferredVoice = voices.find(v => /en-(US|GB)/.test(v.lang));
   
    utterance.voice = preferredVoice || voices.find(v => v.lang && v.lang.startsWith('en-')); 
    utterance.lang = utterance.voice ? utterance.voice.lang : 'en-US';
    utterance.rate = 0.9; 
    utterance.pitch = 1;
    speechSynthesis.cancel(); 
    speechSynthesis.speak(utterance);
  }

  updateScoreDisplay() {
    this.scoreDisplayEl.textContent = `スコア: ${this.score}/${this.attempts}`;
    // Progress bar can be based on questions attempted if time is unlimited,
    // or on time elapsed if time is limited.
    // For now, it reflects correct answers / total attempts.
    const progressPercentage = this.attempts > 0 ? (this.score / this.attempts) * 100 : 0;
    this.progressFillEl.style.width = `${progressPercentage}%`;
  }

  endGame() {
    this.isPlaying = false;
    if (this.timerIntervalId) clearInterval(this.timerIntervalId);
   
    this.gameScreenEl.style.display = 'none';
    this.resultScreenEl.style.display = 'block';
   
    const percentage = this.attempts > 0 ? Math.round((this.score / this.attempts) * 100) : 0;
    this.finalScoreEl.textContent = `${this.score} / ${this.attempts} (${percentage}%)`;
   
    let message = "お疲れ様！";
    if (percentage >= 95) message = "素晴らしい！ほぼパーフェクト！🎉 さらなる高みを目指そう！";
    else if (percentage >= 80) message = "すごい！高得点だね！✨ 次は90%越えに挑戦！";
    else if (percentage >= 60) message = "良い調子！その調子で語彙力をアップ！👍";
    else if (percentage >= 40) message = "ナイスチャレンジ！続けることが一番の力だよ！💪";
    else message = "たくさん練習して、得意な単語を増やしていこう！😊 ファイト！";
    this.finalMessageEl.textContent = message;
    if(audioCtx && sounds.start) playSound('start'); 
  }

  restartGame() {
    // ★MODIFIED: Restart button click sound logic moved here to ensure it plays.
    // It's not strictly a "setup screen button" but a primary action button.
    // Let's keep it for consistency or remove if only setup screen buttons should have generic click.
    // User specified "top pageのみ", result screen isn't top page. Let's rely on existing sound logic.
    // The original `playSound('click')` was already here, so it's fine.
    if(audioCtx && sounds.click) playSound('click');

    if (this.timerIntervalId) clearInterval(this.timerIntervalId);
   
    this.resultScreenEl.style.display = 'none';
    this.setupScreenEl.style.display = 'block';
    this.gameScreenEl.style.display = 'none'; 

    document.querySelectorAll('.btn.selected').forEach(b => b.classList.remove('selected'));
    const defaultDirBtn = document.querySelector('.dir-btn[data-mode="en-ja"]');
    if (defaultDirBtn) defaultDirBtn.classList.add('selected');
    this.playMode = 'en-ja';


    this.progressFillEl.style.width = '0%';
    this.currentWordEl.textContent = 'Loading...';
    this.choicesEl.innerHTML = '';
    this.answerDisplayEl.className = 'answer-display'; // Reset and hide
    this.timerDisplayEl.textContent = '時間: --';
    this.scoreDisplayEl.textContent = 'スコア: 0/0';

    this.level = null;
    this.timeLimit = null;
    this.updateStartButtonState();
  }
}

window.addEventListener('DOMContentLoaded', () => {
  new BlastTrainer();
  if ('speechSynthesis' in window && typeof speechSynthesis.getVoices === 'function') {
    const polly = setInterval(() => {
        if (speechSynthesis.getVoices().length) {
            clearInterval(polly);
        } else {
            speechSynthesis.getVoices(); 
        }
    }, 200);
  }
});
</script>
</body>
</html>